// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'location_permission.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LocationPermission {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Denied value) denied,
    required TResult Function(DeniedForever value) deniedForever,
    required TResult Function(WhileInUse value) whileInUse,
    required TResult Function(Always value) always,
    required TResult Function(UnableToDetermine value) unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Denied value)? denied,
    TResult? Function(DeniedForever value)? deniedForever,
    TResult? Function(WhileInUse value)? whileInUse,
    TResult? Function(Always value)? always,
    TResult? Function(UnableToDetermine value)? unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Denied value)? denied,
    TResult Function(DeniedForever value)? deniedForever,
    TResult Function(WhileInUse value)? whileInUse,
    TResult Function(Always value)? always,
    TResult Function(UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocationPermissionCopyWith<$Res> {
  factory $LocationPermissionCopyWith(
          LocationPermission value, $Res Function(LocationPermission) then) =
      _$LocationPermissionCopyWithImpl<$Res, LocationPermission>;
}

/// @nodoc
class _$LocationPermissionCopyWithImpl<$Res, $Val extends LocationPermission>
    implements $LocationPermissionCopyWith<$Res> {
  _$LocationPermissionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DeniedCopyWith<$Res> {
  factory _$$DeniedCopyWith(_$Denied value, $Res Function(_$Denied) then) =
      __$$DeniedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DeniedCopyWithImpl<$Res>
    extends _$LocationPermissionCopyWithImpl<$Res, _$Denied>
    implements _$$DeniedCopyWith<$Res> {
  __$$DeniedCopyWithImpl(_$Denied _value, $Res Function(_$Denied) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Denied implements Denied {
  const _$Denied();

  @override
  String toString() {
    return 'LocationPermission.denied()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Denied);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() unableToDetermine,
  }) {
    return denied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? unableToDetermine,
  }) {
    return denied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (denied != null) {
      return denied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Denied value) denied,
    required TResult Function(DeniedForever value) deniedForever,
    required TResult Function(WhileInUse value) whileInUse,
    required TResult Function(Always value) always,
    required TResult Function(UnableToDetermine value) unableToDetermine,
  }) {
    return denied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Denied value)? denied,
    TResult? Function(DeniedForever value)? deniedForever,
    TResult? Function(WhileInUse value)? whileInUse,
    TResult? Function(Always value)? always,
    TResult? Function(UnableToDetermine value)? unableToDetermine,
  }) {
    return denied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Denied value)? denied,
    TResult Function(DeniedForever value)? deniedForever,
    TResult Function(WhileInUse value)? whileInUse,
    TResult Function(Always value)? always,
    TResult Function(UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (denied != null) {
      return denied(this);
    }
    return orElse();
  }
}

abstract class Denied implements LocationPermission {
  const factory Denied() = _$Denied;
}

/// @nodoc
abstract class _$$DeniedForeverCopyWith<$Res> {
  factory _$$DeniedForeverCopyWith(
          _$DeniedForever value, $Res Function(_$DeniedForever) then) =
      __$$DeniedForeverCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DeniedForeverCopyWithImpl<$Res>
    extends _$LocationPermissionCopyWithImpl<$Res, _$DeniedForever>
    implements _$$DeniedForeverCopyWith<$Res> {
  __$$DeniedForeverCopyWithImpl(
      _$DeniedForever _value, $Res Function(_$DeniedForever) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DeniedForever implements DeniedForever {
  const _$DeniedForever();

  @override
  String toString() {
    return 'LocationPermission.deniedForever()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DeniedForever);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() unableToDetermine,
  }) {
    return deniedForever();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? unableToDetermine,
  }) {
    return deniedForever?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (deniedForever != null) {
      return deniedForever();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Denied value) denied,
    required TResult Function(DeniedForever value) deniedForever,
    required TResult Function(WhileInUse value) whileInUse,
    required TResult Function(Always value) always,
    required TResult Function(UnableToDetermine value) unableToDetermine,
  }) {
    return deniedForever(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Denied value)? denied,
    TResult? Function(DeniedForever value)? deniedForever,
    TResult? Function(WhileInUse value)? whileInUse,
    TResult? Function(Always value)? always,
    TResult? Function(UnableToDetermine value)? unableToDetermine,
  }) {
    return deniedForever?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Denied value)? denied,
    TResult Function(DeniedForever value)? deniedForever,
    TResult Function(WhileInUse value)? whileInUse,
    TResult Function(Always value)? always,
    TResult Function(UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (deniedForever != null) {
      return deniedForever(this);
    }
    return orElse();
  }
}

abstract class DeniedForever implements LocationPermission {
  const factory DeniedForever() = _$DeniedForever;
}

/// @nodoc
abstract class _$$WhileInUseCopyWith<$Res> {
  factory _$$WhileInUseCopyWith(
          _$WhileInUse value, $Res Function(_$WhileInUse) then) =
      __$$WhileInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WhileInUseCopyWithImpl<$Res>
    extends _$LocationPermissionCopyWithImpl<$Res, _$WhileInUse>
    implements _$$WhileInUseCopyWith<$Res> {
  __$$WhileInUseCopyWithImpl(
      _$WhileInUse _value, $Res Function(_$WhileInUse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WhileInUse implements WhileInUse {
  const _$WhileInUse();

  @override
  String toString() {
    return 'LocationPermission.whileInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WhileInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() unableToDetermine,
  }) {
    return whileInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? unableToDetermine,
  }) {
    return whileInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (whileInUse != null) {
      return whileInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Denied value) denied,
    required TResult Function(DeniedForever value) deniedForever,
    required TResult Function(WhileInUse value) whileInUse,
    required TResult Function(Always value) always,
    required TResult Function(UnableToDetermine value) unableToDetermine,
  }) {
    return whileInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Denied value)? denied,
    TResult? Function(DeniedForever value)? deniedForever,
    TResult? Function(WhileInUse value)? whileInUse,
    TResult? Function(Always value)? always,
    TResult? Function(UnableToDetermine value)? unableToDetermine,
  }) {
    return whileInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Denied value)? denied,
    TResult Function(DeniedForever value)? deniedForever,
    TResult Function(WhileInUse value)? whileInUse,
    TResult Function(Always value)? always,
    TResult Function(UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (whileInUse != null) {
      return whileInUse(this);
    }
    return orElse();
  }
}

abstract class WhileInUse implements LocationPermission {
  const factory WhileInUse() = _$WhileInUse;
}

/// @nodoc
abstract class _$$AlwaysCopyWith<$Res> {
  factory _$$AlwaysCopyWith(_$Always value, $Res Function(_$Always) then) =
      __$$AlwaysCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AlwaysCopyWithImpl<$Res>
    extends _$LocationPermissionCopyWithImpl<$Res, _$Always>
    implements _$$AlwaysCopyWith<$Res> {
  __$$AlwaysCopyWithImpl(_$Always _value, $Res Function(_$Always) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Always implements Always {
  const _$Always();

  @override
  String toString() {
    return 'LocationPermission.always()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Always);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() unableToDetermine,
  }) {
    return always();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? unableToDetermine,
  }) {
    return always?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (always != null) {
      return always();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Denied value) denied,
    required TResult Function(DeniedForever value) deniedForever,
    required TResult Function(WhileInUse value) whileInUse,
    required TResult Function(Always value) always,
    required TResult Function(UnableToDetermine value) unableToDetermine,
  }) {
    return always(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Denied value)? denied,
    TResult? Function(DeniedForever value)? deniedForever,
    TResult? Function(WhileInUse value)? whileInUse,
    TResult? Function(Always value)? always,
    TResult? Function(UnableToDetermine value)? unableToDetermine,
  }) {
    return always?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Denied value)? denied,
    TResult Function(DeniedForever value)? deniedForever,
    TResult Function(WhileInUse value)? whileInUse,
    TResult Function(Always value)? always,
    TResult Function(UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (always != null) {
      return always(this);
    }
    return orElse();
  }
}

abstract class Always implements LocationPermission {
  const factory Always() = _$Always;
}

/// @nodoc
abstract class _$$UnableToDetermineCopyWith<$Res> {
  factory _$$UnableToDetermineCopyWith(
          _$UnableToDetermine value, $Res Function(_$UnableToDetermine) then) =
      __$$UnableToDetermineCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnableToDetermineCopyWithImpl<$Res>
    extends _$LocationPermissionCopyWithImpl<$Res, _$UnableToDetermine>
    implements _$$UnableToDetermineCopyWith<$Res> {
  __$$UnableToDetermineCopyWithImpl(
      _$UnableToDetermine _value, $Res Function(_$UnableToDetermine) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnableToDetermine implements UnableToDetermine {
  const _$UnableToDetermine();

  @override
  String toString() {
    return 'LocationPermission.unableToDetermine()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnableToDetermine);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() unableToDetermine,
  }) {
    return unableToDetermine();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? unableToDetermine,
  }) {
    return unableToDetermine?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (unableToDetermine != null) {
      return unableToDetermine();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Denied value) denied,
    required TResult Function(DeniedForever value) deniedForever,
    required TResult Function(WhileInUse value) whileInUse,
    required TResult Function(Always value) always,
    required TResult Function(UnableToDetermine value) unableToDetermine,
  }) {
    return unableToDetermine(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Denied value)? denied,
    TResult? Function(DeniedForever value)? deniedForever,
    TResult? Function(WhileInUse value)? whileInUse,
    TResult? Function(Always value)? always,
    TResult? Function(UnableToDetermine value)? unableToDetermine,
  }) {
    return unableToDetermine?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Denied value)? denied,
    TResult Function(DeniedForever value)? deniedForever,
    TResult Function(WhileInUse value)? whileInUse,
    TResult Function(Always value)? always,
    TResult Function(UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (unableToDetermine != null) {
      return unableToDetermine(this);
    }
    return orElse();
  }
}

abstract class UnableToDetermine implements LocationPermission {
  const factory UnableToDetermine() = _$UnableToDetermine;
}
