// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'device_permission.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DevicePermission {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DevicePermissionCopyWith<$Res> {
  factory $DevicePermissionCopyWith(
          DevicePermission value, $Res Function(DevicePermission) then) =
      _$DevicePermissionCopyWithImpl<$Res, DevicePermission>;
}

/// @nodoc
class _$DevicePermissionCopyWithImpl<$Res, $Val extends DevicePermission>
    implements $DevicePermissionCopyWith<$Res> {
  _$DevicePermissionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LocationCopyWith<$Res> {
  factory _$$LocationCopyWith(
          _$Location value, $Res Function(_$Location) then) =
      __$$LocationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LocationCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$Location>
    implements _$$LocationCopyWith<$Res> {
  __$$LocationCopyWithImpl(_$Location _value, $Res Function(_$Location) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Location implements Location {
  const _$Location();

  @override
  String toString() {
    return 'DevicePermission.location()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Location);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return location();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return location?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (location != null) {
      return location();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return location(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return location?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (location != null) {
      return location(this);
    }
    return orElse();
  }
}

abstract class Location implements DevicePermission {
  const factory Location() = _$Location;
}

/// @nodoc
abstract class _$$LocationAlwaysCopyWith<$Res> {
  factory _$$LocationAlwaysCopyWith(
          _$LocationAlways value, $Res Function(_$LocationAlways) then) =
      __$$LocationAlwaysCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LocationAlwaysCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$LocationAlways>
    implements _$$LocationAlwaysCopyWith<$Res> {
  __$$LocationAlwaysCopyWithImpl(
      _$LocationAlways _value, $Res Function(_$LocationAlways) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LocationAlways implements LocationAlways {
  const _$LocationAlways();

  @override
  String toString() {
    return 'DevicePermission.locationAlways()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LocationAlways);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return locationAlways();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return locationAlways?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (locationAlways != null) {
      return locationAlways();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return locationAlways(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return locationAlways?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (locationAlways != null) {
      return locationAlways(this);
    }
    return orElse();
  }
}

abstract class LocationAlways implements DevicePermission {
  const factory LocationAlways() = _$LocationAlways;
}

/// @nodoc
abstract class _$$LocationWhenInUseCopyWith<$Res> {
  factory _$$LocationWhenInUseCopyWith(
          _$LocationWhenInUse value, $Res Function(_$LocationWhenInUse) then) =
      __$$LocationWhenInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LocationWhenInUseCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$LocationWhenInUse>
    implements _$$LocationWhenInUseCopyWith<$Res> {
  __$$LocationWhenInUseCopyWithImpl(
      _$LocationWhenInUse _value, $Res Function(_$LocationWhenInUse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LocationWhenInUse implements LocationWhenInUse {
  const _$LocationWhenInUse();

  @override
  String toString() {
    return 'DevicePermission.locationWhenInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LocationWhenInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return locationWhenInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return locationWhenInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (locationWhenInUse != null) {
      return locationWhenInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return locationWhenInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return locationWhenInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (locationWhenInUse != null) {
      return locationWhenInUse(this);
    }
    return orElse();
  }
}

abstract class LocationWhenInUse implements DevicePermission {
  const factory LocationWhenInUse() = _$LocationWhenInUse;
}

/// @nodoc
abstract class _$$MotionSensorsCopyWith<$Res> {
  factory _$$MotionSensorsCopyWith(
          _$MotionSensors value, $Res Function(_$MotionSensors) then) =
      __$$MotionSensorsCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MotionSensorsCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$MotionSensors>
    implements _$$MotionSensorsCopyWith<$Res> {
  __$$MotionSensorsCopyWithImpl(
      _$MotionSensors _value, $Res Function(_$MotionSensors) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MotionSensors implements MotionSensors {
  const _$MotionSensors();

  @override
  String toString() {
    return 'DevicePermission.motionSensors()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MotionSensors);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return motionSensors();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return motionSensors?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (motionSensors != null) {
      return motionSensors();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return motionSensors(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return motionSensors?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (motionSensors != null) {
      return motionSensors(this);
    }
    return orElse();
  }
}

abstract class MotionSensors implements DevicePermission {
  const factory MotionSensors() = _$MotionSensors;
}

/// @nodoc
abstract class _$$BluetoothCopyWith<$Res> {
  factory _$$BluetoothCopyWith(
          _$Bluetooth value, $Res Function(_$Bluetooth) then) =
      __$$BluetoothCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BluetoothCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$Bluetooth>
    implements _$$BluetoothCopyWith<$Res> {
  __$$BluetoothCopyWithImpl(
      _$Bluetooth _value, $Res Function(_$Bluetooth) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Bluetooth implements Bluetooth {
  const _$Bluetooth();

  @override
  String toString() {
    return 'DevicePermission.bluetooth()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Bluetooth);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return bluetooth();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return bluetooth?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetooth != null) {
      return bluetooth();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return bluetooth(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return bluetooth?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetooth != null) {
      return bluetooth(this);
    }
    return orElse();
  }
}

abstract class Bluetooth implements DevicePermission {
  const factory Bluetooth() = _$Bluetooth;
}

/// @nodoc
abstract class _$$BluetoothScanCopyWith<$Res> {
  factory _$$BluetoothScanCopyWith(
          _$BluetoothScan value, $Res Function(_$BluetoothScan) then) =
      __$$BluetoothScanCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BluetoothScanCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$BluetoothScan>
    implements _$$BluetoothScanCopyWith<$Res> {
  __$$BluetoothScanCopyWithImpl(
      _$BluetoothScan _value, $Res Function(_$BluetoothScan) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BluetoothScan implements BluetoothScan {
  const _$BluetoothScan();

  @override
  String toString() {
    return 'DevicePermission.bluetoothScan()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BluetoothScan);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return bluetoothScan();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return bluetoothScan?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetoothScan != null) {
      return bluetoothScan();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return bluetoothScan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return bluetoothScan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetoothScan != null) {
      return bluetoothScan(this);
    }
    return orElse();
  }
}

abstract class BluetoothScan implements DevicePermission {
  const factory BluetoothScan() = _$BluetoothScan;
}

/// @nodoc
abstract class _$$BluetoothAdvertiseCopyWith<$Res> {
  factory _$$BluetoothAdvertiseCopyWith(_$BluetoothAdvertise value,
          $Res Function(_$BluetoothAdvertise) then) =
      __$$BluetoothAdvertiseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BluetoothAdvertiseCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$BluetoothAdvertise>
    implements _$$BluetoothAdvertiseCopyWith<$Res> {
  __$$BluetoothAdvertiseCopyWithImpl(
      _$BluetoothAdvertise _value, $Res Function(_$BluetoothAdvertise) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BluetoothAdvertise implements BluetoothAdvertise {
  const _$BluetoothAdvertise();

  @override
  String toString() {
    return 'DevicePermission.bluetoothAdvertise()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BluetoothAdvertise);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return bluetoothAdvertise();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return bluetoothAdvertise?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetoothAdvertise != null) {
      return bluetoothAdvertise();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return bluetoothAdvertise(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return bluetoothAdvertise?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetoothAdvertise != null) {
      return bluetoothAdvertise(this);
    }
    return orElse();
  }
}

abstract class BluetoothAdvertise implements DevicePermission {
  const factory BluetoothAdvertise() = _$BluetoothAdvertise;
}

/// @nodoc
abstract class _$$BluetoothConnectCopyWith<$Res> {
  factory _$$BluetoothConnectCopyWith(
          _$BluetoothConnect value, $Res Function(_$BluetoothConnect) then) =
      __$$BluetoothConnectCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BluetoothConnectCopyWithImpl<$Res>
    extends _$DevicePermissionCopyWithImpl<$Res, _$BluetoothConnect>
    implements _$$BluetoothConnectCopyWith<$Res> {
  __$$BluetoothConnectCopyWithImpl(
      _$BluetoothConnect _value, $Res Function(_$BluetoothConnect) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BluetoothConnect implements BluetoothConnect {
  const _$BluetoothConnect();

  @override
  String toString() {
    return 'DevicePermission.bluetoothConnect()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BluetoothConnect);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() location,
    required TResult Function() locationAlways,
    required TResult Function() locationWhenInUse,
    required TResult Function() motionSensors,
    required TResult Function() bluetooth,
    required TResult Function() bluetoothScan,
    required TResult Function() bluetoothAdvertise,
    required TResult Function() bluetoothConnect,
  }) {
    return bluetoothConnect();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? location,
    TResult? Function()? locationAlways,
    TResult? Function()? locationWhenInUse,
    TResult? Function()? motionSensors,
    TResult? Function()? bluetooth,
    TResult? Function()? bluetoothScan,
    TResult? Function()? bluetoothAdvertise,
    TResult? Function()? bluetoothConnect,
  }) {
    return bluetoothConnect?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? location,
    TResult Function()? locationAlways,
    TResult Function()? locationWhenInUse,
    TResult Function()? motionSensors,
    TResult Function()? bluetooth,
    TResult Function()? bluetoothScan,
    TResult Function()? bluetoothAdvertise,
    TResult Function()? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetoothConnect != null) {
      return bluetoothConnect();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Location value) location,
    required TResult Function(LocationAlways value) locationAlways,
    required TResult Function(LocationWhenInUse value) locationWhenInUse,
    required TResult Function(MotionSensors value) motionSensors,
    required TResult Function(Bluetooth value) bluetooth,
    required TResult Function(BluetoothScan value) bluetoothScan,
    required TResult Function(BluetoothAdvertise value) bluetoothAdvertise,
    required TResult Function(BluetoothConnect value) bluetoothConnect,
  }) {
    return bluetoothConnect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Location value)? location,
    TResult? Function(LocationAlways value)? locationAlways,
    TResult? Function(LocationWhenInUse value)? locationWhenInUse,
    TResult? Function(MotionSensors value)? motionSensors,
    TResult? Function(Bluetooth value)? bluetooth,
    TResult? Function(BluetoothScan value)? bluetoothScan,
    TResult? Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult? Function(BluetoothConnect value)? bluetoothConnect,
  }) {
    return bluetoothConnect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Location value)? location,
    TResult Function(LocationAlways value)? locationAlways,
    TResult Function(LocationWhenInUse value)? locationWhenInUse,
    TResult Function(MotionSensors value)? motionSensors,
    TResult Function(Bluetooth value)? bluetooth,
    TResult Function(BluetoothScan value)? bluetoothScan,
    TResult Function(BluetoothAdvertise value)? bluetoothAdvertise,
    TResult Function(BluetoothConnect value)? bluetoothConnect,
    required TResult orElse(),
  }) {
    if (bluetoothConnect != null) {
      return bluetoothConnect(this);
    }
    return orElse();
  }
}

abstract class BluetoothConnect implements DevicePermission {
  const factory BluetoothConnect() = _$BluetoothConnect;
}
