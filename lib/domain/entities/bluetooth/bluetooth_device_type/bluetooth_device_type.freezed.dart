// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bluetooth_device_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BluetoothDeviceType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() classic,
    required TResult Function() le,
    required TResult Function() dual,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? classic,
    TResult? Function()? le,
    TResult? Function()? dual,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? classic,
    TResult Function()? le,
    TResult Function()? dual,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unknown value) unknown,
    required TResult Function(Classic value) classic,
    required TResult Function(Le value) le,
    required TResult Function(Dual value) dual,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Unknown value)? unknown,
    TResult? Function(Classic value)? classic,
    TResult? Function(Le value)? le,
    TResult? Function(Dual value)? dual,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unknown value)? unknown,
    TResult Function(Classic value)? classic,
    TResult Function(Le value)? le,
    TResult Function(Dual value)? dual,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BluetoothDeviceTypeCopyWith<$Res> {
  factory $BluetoothDeviceTypeCopyWith(
          BluetoothDeviceType value, $Res Function(BluetoothDeviceType) then) =
      _$BluetoothDeviceTypeCopyWithImpl<$Res, BluetoothDeviceType>;
}

/// @nodoc
class _$BluetoothDeviceTypeCopyWithImpl<$Res, $Val extends BluetoothDeviceType>
    implements $BluetoothDeviceTypeCopyWith<$Res> {
  _$BluetoothDeviceTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UnknownCopyWith<$Res> {
  factory _$$UnknownCopyWith(_$Unknown value, $Res Function(_$Unknown) then) =
      __$$UnknownCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownCopyWithImpl<$Res>
    extends _$BluetoothDeviceTypeCopyWithImpl<$Res, _$Unknown>
    implements _$$UnknownCopyWith<$Res> {
  __$$UnknownCopyWithImpl(_$Unknown _value, $Res Function(_$Unknown) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Unknown extends Unknown {
  const _$Unknown() : super._();

  @override
  String toString() {
    return 'BluetoothDeviceType.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() classic,
    required TResult Function() le,
    required TResult Function() dual,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? classic,
    TResult? Function()? le,
    TResult? Function()? dual,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? classic,
    TResult Function()? le,
    TResult Function()? dual,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unknown value) unknown,
    required TResult Function(Classic value) classic,
    required TResult Function(Le value) le,
    required TResult Function(Dual value) dual,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Unknown value)? unknown,
    TResult? Function(Classic value)? classic,
    TResult? Function(Le value)? le,
    TResult? Function(Dual value)? dual,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unknown value)? unknown,
    TResult Function(Classic value)? classic,
    TResult Function(Le value)? le,
    TResult Function(Dual value)? dual,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class Unknown extends BluetoothDeviceType {
  const factory Unknown() = _$Unknown;
  const Unknown._() : super._();
}

/// @nodoc
abstract class _$$ClassicCopyWith<$Res> {
  factory _$$ClassicCopyWith(_$Classic value, $Res Function(_$Classic) then) =
      __$$ClassicCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClassicCopyWithImpl<$Res>
    extends _$BluetoothDeviceTypeCopyWithImpl<$Res, _$Classic>
    implements _$$ClassicCopyWith<$Res> {
  __$$ClassicCopyWithImpl(_$Classic _value, $Res Function(_$Classic) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Classic extends Classic {
  const _$Classic() : super._();

  @override
  String toString() {
    return 'BluetoothDeviceType.classic()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Classic);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() classic,
    required TResult Function() le,
    required TResult Function() dual,
  }) {
    return classic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? classic,
    TResult? Function()? le,
    TResult? Function()? dual,
  }) {
    return classic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? classic,
    TResult Function()? le,
    TResult Function()? dual,
    required TResult orElse(),
  }) {
    if (classic != null) {
      return classic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unknown value) unknown,
    required TResult Function(Classic value) classic,
    required TResult Function(Le value) le,
    required TResult Function(Dual value) dual,
  }) {
    return classic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Unknown value)? unknown,
    TResult? Function(Classic value)? classic,
    TResult? Function(Le value)? le,
    TResult? Function(Dual value)? dual,
  }) {
    return classic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unknown value)? unknown,
    TResult Function(Classic value)? classic,
    TResult Function(Le value)? le,
    TResult Function(Dual value)? dual,
    required TResult orElse(),
  }) {
    if (classic != null) {
      return classic(this);
    }
    return orElse();
  }
}

abstract class Classic extends BluetoothDeviceType {
  const factory Classic() = _$Classic;
  const Classic._() : super._();
}

/// @nodoc
abstract class _$$LeCopyWith<$Res> {
  factory _$$LeCopyWith(_$Le value, $Res Function(_$Le) then) =
      __$$LeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LeCopyWithImpl<$Res>
    extends _$BluetoothDeviceTypeCopyWithImpl<$Res, _$Le>
    implements _$$LeCopyWith<$Res> {
  __$$LeCopyWithImpl(_$Le _value, $Res Function(_$Le) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Le extends Le {
  const _$Le() : super._();

  @override
  String toString() {
    return 'BluetoothDeviceType.le()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Le);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() classic,
    required TResult Function() le,
    required TResult Function() dual,
  }) {
    return le();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? classic,
    TResult? Function()? le,
    TResult? Function()? dual,
  }) {
    return le?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? classic,
    TResult Function()? le,
    TResult Function()? dual,
    required TResult orElse(),
  }) {
    if (le != null) {
      return le();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unknown value) unknown,
    required TResult Function(Classic value) classic,
    required TResult Function(Le value) le,
    required TResult Function(Dual value) dual,
  }) {
    return le(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Unknown value)? unknown,
    TResult? Function(Classic value)? classic,
    TResult? Function(Le value)? le,
    TResult? Function(Dual value)? dual,
  }) {
    return le?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unknown value)? unknown,
    TResult Function(Classic value)? classic,
    TResult Function(Le value)? le,
    TResult Function(Dual value)? dual,
    required TResult orElse(),
  }) {
    if (le != null) {
      return le(this);
    }
    return orElse();
  }
}

abstract class Le extends BluetoothDeviceType {
  const factory Le() = _$Le;
  const Le._() : super._();
}

/// @nodoc
abstract class _$$DualCopyWith<$Res> {
  factory _$$DualCopyWith(_$Dual value, $Res Function(_$Dual) then) =
      __$$DualCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DualCopyWithImpl<$Res>
    extends _$BluetoothDeviceTypeCopyWithImpl<$Res, _$Dual>
    implements _$$DualCopyWith<$Res> {
  __$$DualCopyWithImpl(_$Dual _value, $Res Function(_$Dual) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Dual extends Dual {
  const _$Dual() : super._();

  @override
  String toString() {
    return 'BluetoothDeviceType.dual()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Dual);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() classic,
    required TResult Function() le,
    required TResult Function() dual,
  }) {
    return dual();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? classic,
    TResult? Function()? le,
    TResult? Function()? dual,
  }) {
    return dual?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? classic,
    TResult Function()? le,
    TResult Function()? dual,
    required TResult orElse(),
  }) {
    if (dual != null) {
      return dual();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unknown value) unknown,
    required TResult Function(Classic value) classic,
    required TResult Function(Le value) le,
    required TResult Function(Dual value) dual,
  }) {
    return dual(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Unknown value)? unknown,
    TResult? Function(Classic value)? classic,
    TResult? Function(Le value)? le,
    TResult? Function(Dual value)? dual,
  }) {
    return dual?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unknown value)? unknown,
    TResult Function(Classic value)? classic,
    TResult Function(Le value)? le,
    TResult Function(Dual value)? dual,
    required TResult orElse(),
  }) {
    if (dual != null) {
      return dual(this);
    }
    return orElse();
  }
}

abstract class Dual extends BluetoothDeviceType {
  const factory Dual() = _$Dual;
  const Dual._() : super._();
}
